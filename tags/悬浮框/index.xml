<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>悬浮框 on 编程心语</title>
    <link>https://www.ithome.me/tags/%E6%82%AC%E6%B5%AE%E6%A1%86/</link>
    <description>Recent content in 悬浮框 on 编程心语</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <copyright>©{year}, All Rights Reserved. Simon Chen</copyright>
    <lastBuildDate>Tue, 19 Jan 2016 11:29:46 +0800</lastBuildDate>
    <atom:link href="https://www.ithome.me/tags/%E6%82%AC%E6%B5%AE%E6%A1%86/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Android无需权限显示悬浮窗, 兼谈逆向分析app</title>
      <link>https://www.ithome.me/post/2016/01/19/android%E6%97%A0%E9%9C%80%E6%9D%83%E9%99%90%E6%98%BE%E7%A4%BA%E6%82%AC%E6%B5%AE%E7%AA%97-%E5%85%BC%E8%B0%88%E9%80%86%E5%90%91%E5%88%86%E6%9E%90app/</link>
      <pubDate>Tue, 19 Jan 2016 11:29:46 +0800</pubDate>
      <guid>https://www.ithome.me/post/2016/01/19/android%E6%97%A0%E9%9C%80%E6%9D%83%E9%99%90%E6%98%BE%E7%A4%BA%E6%82%AC%E6%B5%AE%E7%AA%97-%E5%85%BC%E8%B0%88%E9%80%86%E5%90%91%E5%88%86%E6%9E%90app/</guid>
      <description>&lt;div class=&#34;tip&#34;&gt;最近UC浏览器中文版出了一个快速搜索的功能, 在使用其他app的时候, 如果复制了一些内容, 屏幕顶部会弹一个窗口, 提示一些操作, 点击后跳转到UC, 显示这个悬浮窗不需要申请`android.permission.SYSTEM_ALERT_WINDOW`权限.&lt;/div&gt;&#xA;&lt;p&gt;如下图, 截图是在使用Chrome时截的, 但是屏幕顶部却有UC的view浮在屏幕上. 我使用的是小米, 我并没有给UC授悬浮窗权限, 所以我看到这个悬浮窗时是很震惊的.&lt;/p&gt;&#xA;&lt;p&gt;&lt;img&#xA;        class=&#34;lazyload&#34;&#xA;        src=&#34;https://www.ithome.me/svg/loading.min.svg&#34;&#xA;        data-src=&#34;http://ww4.sinaimg.cn/large/62b0904dgw1f04v52p27dj20c80lqabw.jpg&#34;&#xA;        data-srcset=&#34;http://ww4.sinaimg.cn/large/62b0904dgw1f04v52p27dj20c80lqabw.jpg, http://ww4.sinaimg.cn/large/62b0904dgw1f04v52p27dj20c80lqabw.jpg 1.5x, http://ww4.sinaimg.cn/large/62b0904dgw1f04v52p27dj20c80lqabw.jpg 2x&#34;&#xA;        data-sizes=&#34;auto&#34;&#xA;        alt=&#34;http://ww4.sinaimg.cn/large/62b0904dgw1f04v52p27dj20c80lqabw.jpg&#34;&#xA;        title=&#34;http://ww4.sinaimg.cn/large/62b0904dgw1f04v52p27dj20c80lqabw.jpg&#34; /&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;悬浮窗原理&#34;&gt;悬浮窗原理&lt;/h3&gt;&#xA;&lt;p&gt;做过悬浮窗功能的人都知道, 要想显示悬浮窗, 要有一个服务运行在后台, 通过&lt;code&gt;getSystemService(Context.WINDOW_SERVICE)&lt;/code&gt;拿到WindowManager, 然后向其中addView, addView第二个参数是一个&lt;code&gt;WindowManager.LayoutParams&lt;/code&gt;, WindowManager.LayoutParams中有一个成员type, 有各种值, 一般设置成TYPE_PHONE就可以悬浮在很多view的上方了, 但是调用这个方法需要申请&lt;code&gt;android.permission.SYSTEM_ALERT_WINDOW&lt;/code&gt;权限, 在很多机型上, 这个权限的名字叫悬浮窗, 比如小米手机上默认是禁用这个权限的, 有些恶意app会用这个权限弹广告, 而且很难追查是哪个应用弹的. 如果这个权限被禁用, 那么结果就是悬浮窗无法展示, 比如有道词典的复制查词功能, 在小米手机上经常没用, 其实是用户没有授权, 而且应用也没有引导用户给它打开授权.&lt;/p&gt;&#xA;&lt;p&gt;那么他是怎么实现的呢？有人就进行了逆向分析。&lt;/p&gt;&#xA;&lt;p&gt;过程省略。。。直接说结论&lt;/p&gt;&#xA;&lt;!-- more --&gt;&#xA;&lt;h3 id=&#34;验证&#34;&gt;验证&lt;/h3&gt;&#xA;&lt;p&gt;实际测试了一下, 将type设置成TYPE_TOAST果然有奇效, 不需要&lt;code&gt;android.permission.SYSTEM_ALERT_WINDOW&lt;/code&gt;权限就能显示一个悬浮窗.&lt;/p&gt;&#xA;&lt;p&gt;之前我一直以为调用了系统&lt;code&gt;WindowManager.addView&lt;/code&gt;需要&lt;code&gt;android.permission.SYSTEM_ALERT_WINDOW&lt;/code&gt;权限, 但实际上调用这个方法是不需要权限的, 在Android源码中有这么一段&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public int checkAddPermission(WindowManager.LayoutParams attrs) {&#xA;    int type = attrs.type;&#xA;&#xA;    if (type &amp;lt; WindowManager.LayoutParams.FIRST_SYSTEM_WINDOW&#xA;            || type &amp;gt; WindowManager.LayoutParams.LAST_SYSTEM_WINDOW) {&#xA;        return WindowManagerImpl.ADD_OKAY;&#xA;    }&#xA;    String permission = null;&#xA;    switch (type) {&#xA;        case TYPE_TOAST:&#xA;            // XXX right now the app process has complete control over&#xA;            // this...  should introduce a token to let the system&#xA;            // monitor/control what they are doing.&#xA;            break;&#xA;        case TYPE_INPUT_METHOD:&#xA;        case TYPE_WALLPAPER:&#xA;            // The window manager will check these.&#xA;            break;&#xA;        case TYPE_PHONE:&#xA;        case TYPE_PRIORITY_PHONE:&#xA;        case TYPE_SYSTEM_ALERT:&#xA;        case TYPE_SYSTEM_ERROR:&#xA;        case TYPE_SYSTEM_OVERLAY:&#xA;            permission = android.Manifest.permission.SYSTEM_ALERT_WINDOW;&#xA;            break;&#xA;        default:&#xA;            permission = android.Manifest.permission.INTERNAL_SYSTEM_WINDOW;&#xA;    }&#xA;    if (permission != null) {&#xA;        if (mContext.checkCallingOrSelfPermission(permission)&#xA;                != PackageManager.PERMISSION_GRANTED) {&#xA;            return WindowManagerImpl.ADD_PERMISSION_DENIED;&#xA;        }&#xA;    }&#xA;    return WindowManagerImpl.ADD_OKAY;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以猜到这个方法是往系统的WindowManager里addView的时候做权限检查用的, 那个&lt;code&gt;type&lt;/code&gt;就是我们在构造&lt;code&gt;WindowManager.LayoutParams&lt;/code&gt;时赋值的&lt;code&gt;type&lt;/code&gt;, 可以看到, 除了&lt;code&gt;TYPE_TOAST&lt;/code&gt;, 其他都是要权限的, 而且非常喜感的是, 代码中的注释还说他们现在对这种type毫无限制, 应该引入标记来限制开发者.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
