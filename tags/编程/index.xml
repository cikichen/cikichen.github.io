<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>编程 on 编程心语</title>
    <link>https://www.ithome.me/tags/%E7%BC%96%E7%A8%8B/</link>
    <description>Recent content in 编程 on 编程心语</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <copyright>©{year}, All Rights Reserved. Simon Chen</copyright>
    <lastBuildDate>Fri, 17 Dec 2021 12:17:10 +0800</lastBuildDate>
    <atom:link href="https://www.ithome.me/tags/%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>手摸手极简docker部署rocketmq单机实战</title>
      <link>https://www.ithome.me/post/2021/12/17/docker%E9%83%A8%E7%BD%B2rocketmq%E5%8D%95%E6%9C%BA%E5%AE%9E%E6%88%98/</link>
      <pubDate>Fri, 17 Dec 2021 12:17:10 +0800</pubDate>
      <guid>https://www.ithome.me/post/2021/12/17/docker%E9%83%A8%E7%BD%B2rocketmq%E5%8D%95%E6%9C%BA%E5%AE%9E%E6%88%98/</guid>
      <description>&lt;p&gt;自己本地搭建rocketmq开发环境还是用docker方便点，之前搭建一直有些小问题，最近专项解决了下，终于搞定了，这里整理分享下&lt;/p&gt;&#xA;&lt;h3 id=&#34;环境准备&#34;&gt;环境准备&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;因笔者用的MacBook，所以会主要以Mac为主讲解，其他环境区别不大&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;首先请准备好docker环境，推荐&lt;a href=&#34;https://www.docker.com/products/docker-desktop&#34; target=&#34;_blank&#34; rel=&#34;noopener noreffer&#34;&gt;docker desktop&lt;/a&gt;&#xA;，无他，点点点就完事了，不用的时候不启动，开发机紧张的内存问题得到了心理上的安慰。&lt;/p&gt;&#xA;&lt;p&gt;还需要安装好&lt;code&gt;docker-compose&lt;/code&gt;，请自行参考安装教程&lt;a href=&#34;https://docs.docker.com/compose/install/&#34; target=&#34;_blank&#34; rel=&#34;noopener noreffer&#34;&gt;点这里&lt;/a&gt;&#xA;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;注：&lt;code&gt;docker desktop&lt;/code&gt;自带了docker-compose，所以不需要再单独安装compose了&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;编译rocketmq镜像&#34;&gt;编译rocketmq镜像&lt;/h3&gt;&#xA;&lt;p&gt;环境搞定了，我们开始搭建rocketmq，直接用官方推荐的docker镜像即可。&#xA;镜像下载地址：&lt;a href=&#34;https://github.com/apache/rocketmq-docker&#34; target=&#34;_blank&#34; rel=&#34;noopener noreffer&#34;&gt;https://github.com/apache/rocketmq-docker&lt;/a&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;我们先通过&lt;code&gt;git&lt;/code&gt;把代码拉下来，打开命令行复制粘贴&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;git clone https://hub.fastgit.org/apache/rocketmq-docker.git&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;clone完成后，继续&lt;code&gt;cd rocketmq-docker/image-build&lt;/code&gt;到image-build目录下&lt;/p&gt;&#xA;&lt;p&gt;目前最新版本为&lt;code&gt;4.9.2&lt;/code&gt;,我们就以这个版本为例：&#xA;继续输入下列指令&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sh build-image.sh 4.9.2 alpine&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;等待完成就即可，如果报错，请自行根据错误查找原因。只要环境没问题，编译完成后我们能得到&lt;code&gt;apacherocketmq/rocketmq&lt;/code&gt;镜像&lt;/p&gt;&#xA;&lt;p&gt;至此，我们已经完成了一半的工作。&lt;/p&gt;&#xA;&lt;h3 id=&#34;编写docker-compose配置&#34;&gt;编写docker-compose配置&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;鲁迅：授人以鱼不如授人以渔和鱼&#xA;有经验的同学此时已经急不可耐了，鱼拿去。&#xA;完整的&lt;code&gt;docker-compose.yml&lt;/code&gt;文件&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;version: &amp;#39;3&amp;#39;&#xA;services:&#xA;  namesrv:&#xA;    image: apacherocketmq/rocketmq:4.9.2-alpine&#xA;    container_name: rmqnamesrv&#xA;    ports:&#xA;      - 9876:9876&#xA;    volumes:&#xA;      - ./data/namesrv/logs:/home/rocketmq/logs&#xA;    command: sh mqnamesrv&#xA;    restart: always&#xA;  broker:&#xA;    image: apacherocketmq/rocketmq:4.9.2-alpine&#xA;    container_name: rmqbroker&#xA;    links:&#xA;      - namesrv&#xA;    ports:&#xA;      - 10909:10909&#xA;      - 10911:10911&#xA;      - 10912:10912&#xA;    environment:&#xA;      - NAMESRV_ADDR=namesrv:9876&#xA;    volumes:&#xA;      - ./data/broker/logs:/home/rocketmq/logs&#xA;      - ./data/broker/store:/home/rocketmq/store&#xA;      - ./data/broker/conf/broker.conf:/home/rocketmq/rocketmq-4.9.2/conf/broker.conf&#xA;      - ./data/broker/runbroker.sh:/home/rocketmq/rocketmq-4.9.2/bin/runbroker.sh&#xA;    command: sh mqbroker -c /home/rocketmq/rocketmq-4.9.2/conf/broker.conf&#xA;    depends_on:&#xA;      - namesrv&#xA;    restart: always&#xA;  rmqconsole:&#xA;    image: candice0630/rocketmq-console-ng:2.0&#xA;    container_name: rmqconsole&#xA;    ports:&#xA;      - 9001:8080&#xA;    environment:&#xA;      JAVA_OPTS: -Drocketmq.namesrv.addr=namesrv:9876&#xA;        -Dcom.rocketmq.sendMessageWithVIPChannel=false&#xA;    depends_on:&#xA;      - namesrv&#xA;    restart: always&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面一共三个images，&lt;code&gt;namesrv&lt;/code&gt;、&lt;code&gt;broker&lt;/code&gt;和&lt;code&gt;rmqconsole&lt;/code&gt;&#xA;熟悉&lt;code&gt;docker-compose&lt;/code&gt;的同学可以直接跳过这部分了&#xA;本部分主要结合上面的配置来说，不适应的根据自己的习惯自行更改&#xA;先建立一个&lt;code&gt;rocketmq&lt;/code&gt;文件夹，然后在文件夹下面创建&lt;code&gt;docker-compose.yml&lt;/code&gt;文件，复制上面的内容进去。在&lt;code&gt;docker-compose.yml&lt;/code&gt;同级目录下创建&lt;code&gt;data&lt;/code&gt;文件夹，在&lt;code&gt;data&lt;/code&gt;文件夹下分别创建&lt;code&gt;broker&lt;/code&gt;和&lt;code&gt;namesrv&lt;/code&gt;文件夹，&lt;code&gt;broker&lt;/code&gt;目录下分别创建&lt;code&gt;conf&lt;/code&gt;、&lt;code&gt;logs&lt;/code&gt;和&lt;code&gt;store&lt;/code&gt;文件夹。&lt;code&gt;namesrv&lt;/code&gt;目录下创建&lt;code&gt;logs&lt;/code&gt;目录，&lt;code&gt;logs&lt;/code&gt;目录下创建&lt;code&gt;rocketmqlogs&lt;/code&gt;目录，这样所有的目录创建完成。自定义的&lt;code&gt;broker.conf&lt;/code&gt;文件放到&lt;code&gt;data/broker/conf&lt;/code&gt;目录下。&lt;/p&gt;</description>
    </item>
    <item>
      <title>There is an issue with node-fibers</title>
      <link>https://www.ithome.me/post/2021/05/12/m1%E6%97%A0%E6%B3%95%E7%BC%96%E8%AF%91taro%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
      <pubDate>Wed, 12 May 2021 20:34:08 +0800</pubDate>
      <guid>https://www.ithome.me/post/2021/05/12/m1%E6%97%A0%E6%B3%95%E7%BC%96%E8%AF%91taro%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
      <description>&lt;h3 id=&#34;macbook-m1和taro&#34;&gt;&lt;code&gt;MacBook M1&lt;/code&gt;和&lt;code&gt;taro&lt;/code&gt;&lt;/h3&gt;&#xA;&lt;p&gt;在MacBook M1上运行&lt;code&gt;taro&lt;/code&gt;项目&lt;code&gt;yarn dev:h5&lt;/code&gt;的时候会报下面的错误：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;## There is an issue with `node-fibers` ##&#xA;`/node_modules/fibers/bin/darwin-arm64-88/fibers.node` is missing.&#xA;&#xA;Try running this to fix the issue: .nvm/versions/node/v15.5.0/bin/node /node_modules/fibers/build&#xA;Error: Cannot find module &amp;#39;node_modules/fibers/bin/darwin-arm64-88/fibers&amp;#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;找了很久没找到解决方案，知道找个一个类似的问题：https://www.jianshu.com/p/145015d721a5&lt;/p&gt;&#xA;&lt;h3 id=&#34;解决办法&#34;&gt;解决办法&lt;/h3&gt;&#xA;&lt;p&gt;我的环境如下：&#xA;node： v15.14.0&#xA;taro-cli： v3.2.8&lt;/p&gt;&#xA;&lt;p&gt;先看错误提示:&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;## There is an issue with `node-fibers` ##&#xA;`/node_modules/fibers/bin/darwin-arm64-88/fibers.node` is missing.&#xA;&#xA;Try running this to fix the issue: .nvm/versions/node/v15.14.0/bin/node /node_modules/fibers/build&#xA;Error: Cannot find module &amp;#39;node_modules/fibers/bin/darwin-arm64-88/fibers&amp;#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行&lt;code&gt;/Users/xxx/.nvm/versions/node/v15.14.0/bin/node /Users/xxx/xxx/node_modules/fibers/build&lt;/code&gt;时找不到fibers的&lt;code&gt;darwin-arm64-88&lt;/code&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在项目目录下执行&lt;code&gt;find . -name fibers.node&lt;/code&gt;，看看输出路径有没有&lt;code&gt;darwin-arm64-88&lt;/code&gt;，如果没有，继续下面步骤2&lt;/li&gt;&#xA;&lt;li&gt;在项目目录手动执行&lt;code&gt;/Users/xxx/.nvm/versions/node/v15.14.0/bin/node /Users/xxx/xxx/node_modules/fibers/build&lt;/code&gt;，输出提示&lt;code&gt;node-gyp not found! Please ensure node-gyp is in your PATH--&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;执行&lt;code&gt;npm install -g node-gyp&lt;/code&gt;安装&lt;code&gt;node-gyp&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;再次执行&lt;code&gt;/Users/xxx/.nvm/versions/node/v15.14.0/bin/node /Users/xxx/xxx/node_modules/fibers/build&lt;/code&gt;，此时报错&lt;code&gt;binding.gyp not found&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;项目目录下执行&lt;code&gt;find . -name binding.gyp&lt;/code&gt;，会发现&lt;code&gt;node_modules/fibers/binding.gyp&lt;/code&gt;，项目中是存在这个文件的&lt;/li&gt;&#xA;&lt;li&gt;项目录下下&lt;code&gt;cd node_modules/fibers&lt;/code&gt;，然后再次执行&lt;code&gt;/Users/xxx/.nvm/versions/node/v15.14.0/bin/node /Users/xxx/xxx/node_modules/fibers/build&lt;/code&gt;，不出意外的话此时应该编译通过了。&lt;/li&gt;&#xA;&lt;li&gt;然后&lt;code&gt;cd ../..&lt;/code&gt;，执行&lt;code&gt;yarn dev:h5&lt;/code&gt;，成功启动。&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>Android内存泄漏分析</title>
      <link>https://www.ithome.me/post/2020/10/21/android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 21 Oct 2020 09:38:08 +0800</pubDate>
      <guid>https://www.ithome.me/post/2020/10/21/android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;&#xA;&lt;p&gt;Android内存泄漏，也就是我们常说的&lt;code&gt;OOM(out of memory)&lt;/code&gt;，&lt;code&gt;OOM&lt;/code&gt;的后果大家都知道，严重影响APP的体验，轻则卡顿，重则闪退。而且内存泄漏在低端机上一般都会伴随着&lt;code&gt;ANR&lt;/code&gt;，所以一定要重视它。&lt;/p&gt;&#xA;&lt;p&gt;造成内存泄漏的常见因素有：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IO操作&lt;/li&gt;&#xA;&lt;li&gt;Bitmap&lt;/li&gt;&#xA;&lt;li&gt;Context&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单例持有引用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Service&#xA;&lt;ul&gt;&#xA;&lt;li&gt;BroadcastReceiver&lt;/li&gt;&#xA;&lt;li&gt;ContentObserver&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Handler&lt;/li&gt;&#xA;&lt;li&gt;Thread&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;分析方法&#34;&gt;分析方法&lt;/h2&gt;&#xA;&lt;p&gt;分析内存泄漏的常用方法：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;StrictMode， 在&lt;code&gt;Application&lt;/code&gt;的&lt;code&gt;onCreate&lt;/code&gt;中添加&lt;code&gt;StrictMode&lt;/code&gt;代码块&lt;/li&gt;&#xA;&lt;li&gt;Leakcanary，引用&lt;code&gt;Leakcanary&lt;/code&gt;库(&lt;strong&gt;常规手段，仅供参与，不应完全依赖这个库&lt;/strong&gt;)&lt;/li&gt;&#xA;&lt;li&gt;monkey，模拟用户点击操作，检查是否出现泄漏(&lt;strong&gt;推荐&lt;/strong&gt;，最有效的方法)&lt;/li&gt;&#xA;&lt;li&gt;adb命令手动触发&lt;code&gt;adb shell dumpsys meminfo packagename -d&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;Android Studio Memory Profiler，&lt;code&gt;Android Studio&lt;/code&gt;自带的分析工具，已经非常好用了&lt;/li&gt;&#xA;&lt;li&gt;MAT，终极神器，内存分析绕不开的话题(&lt;code&gt;Android Studio&lt;/code&gt;搞不定就靠它了)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Context&#xA;如果大家收集过内存泄漏的崩溃日志，会发现大量错误都是由&lt;code&gt;Context&lt;/code&gt;和&lt;code&gt;Handler&lt;/code&gt;造成。&#xA;因为我们开发中会大量用到&lt;code&gt;Context&lt;/code&gt;引用，而&lt;code&gt;Context&lt;/code&gt;在&lt;code&gt;Application&lt;/code&gt;，&lt;code&gt;Activity&lt;/code&gt;，&lt;code&gt;Service&lt;/code&gt;之类的地方会有自己的实例，而&lt;code&gt;Activity&lt;/code&gt;和&lt;code&gt;Service&lt;/code&gt;会因为生命周期的原因导致&lt;code&gt;Context&lt;/code&gt;实例被回收，如果你继续使用其引用就会因为弱引用问题导致错误出现。&#xA;&lt;code&gt;Context&lt;/code&gt;的引用也常见于单例模式。&#xA;所以建议大家尽可能使用&lt;code&gt;Application&lt;/code&gt;的&lt;code&gt;Context&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Bitmap&#xA;Bitmap的问题一般是因为没有对使用的图片及时释放所致。&#xA;图片一般因为体积问题，会导致占用比较多的内存&#xA;解决方案：就是在&lt;code&gt;Activity&lt;/code&gt;的&lt;code&gt;onDestroy()&lt;/code&gt;中及时回收内存。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;IO操作&#xA;FileOutputStream()未关闭，IO流忘记关闭&#xA;解决方案：及时关闭IO流，避免泄露&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Handler泄漏&#xA;由于Activity已经关闭，Handler任务还未执行完成，其引用了Activity的实例导致内存泄露&#xA;解决方案：在Activity的onDestroy()方法回收Handler&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;异步线程泄露&#xA;一般发生在线程执行耗时操作时，如下载，此时Activity关闭后，由于其被异步线程引用，导致无法被正常回收，从而内存泄露&#xA;解决方案：把线程作为对象提取出来，在Activity的onDestroy()方法阻塞线程&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;静态成员变量&#xA;开发中会定义许多&lt;code&gt;static&lt;/code&gt;变量，如果有大量的静态变量定义，并有引用资源，一定要在&lt;code&gt;onDestroy&lt;/code&gt;或其他地方及时释放(把变量置空即可)&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>Android高频面试题汇总(一)</title>
      <link>https://www.ithome.me/post/2020/10/21/android%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%80/</link>
      <pubDate>Wed, 21 Oct 2020 11:31:08 +0800</pubDate>
      <guid>https://www.ithome.me/post/2020/10/21/android%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%80/</guid>
      <description>&lt;h3 id=&#34;1leakcanary原理&#34;&gt;1.Leakcanary原理？&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;利用 application.registerActivityLifecycleCallbacks(lifecycleCallbacks) 来监听整个生命周期内的 Activity onDestoryed 事件&lt;/li&gt;&#xA;&lt;li&gt;某个 Activity 被 destory 后，将它传给 RefWatcher 去做观测，确保其后续会被正常回收；&lt;/li&gt;&#xA;&lt;li&gt;RefWatcher 首先把 Activity 使用 KeyedWeakReference 引用起来，并使用一个 ReferenceQueue 来记录该 KeyedWeakReference 指向的对象是否已被回收；&lt;/li&gt;&#xA;&lt;li&gt;AndroidWatchExecutor 会在 5s 后，开始检查这个弱引用内的 Activity 是否被正常回收。判断条件是：若 Activity 被正常回收，那么引用它的 KeyedWeakReference 会被自动放入 ReferenceQueue 中。&lt;/li&gt;&#xA;&lt;li&gt;判断方式是：先看 Activity 对应的 KeyedWeakReference 是否已经放入 ReferenceQueue 中；如果没有，则手动 GC：gcTrigger.runGc();；然后再一次判断 ReferenceQueue 是否已经含有对应的 KeyedWeakReference。若还未被回收，则认为可能发生内存泄漏&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;2如何理解java的多态其中重载和重写有什么区别&#34;&gt;2.如何理解Java的多态？其中，重载和重写有什么区别？&lt;/h3&gt;&#xA;&lt;p&gt;多态是同一个行为具有多个不同表现形式或形态的能力，多态是同一个接口，使用不同的实例而执行不同操作，多态就是程序运行期间才确定，一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法。&#xA;多态存在的三个必要条件是：继承，重写，父类引用指向子类引用。&#xA;多态的三个实现方式是：重写，接口，抽象类和抽象方法。&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;区别点&lt;/th&gt;&#xA;          &lt;th&gt;重载&lt;/th&gt;&#xA;          &lt;th&gt;重写&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;参数列表&lt;/td&gt;&#xA;          &lt;td&gt;必须修改&lt;/td&gt;&#xA;          &lt;td&gt;不能修改&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;返回类型&lt;/td&gt;&#xA;          &lt;td&gt;可以修改&lt;/td&gt;&#xA;          &lt;td&gt;不能修改&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;异常&lt;/td&gt;&#xA;          &lt;td&gt;可以修改&lt;/td&gt;&#xA;          &lt;td&gt;可以减少或删除，一定不能抛出新的或者更广的异常&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;访问&lt;/td&gt;&#xA;          &lt;td&gt;可以修改&lt;/td&gt;&#xA;          &lt;td&gt;一定不能做更严格的限制（可以降低限制）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;3谈一下jvm内存区域划分哪部分是线程公有的哪部分是私有的&#34;&gt;3.谈一下JVM内存区域划分？哪部分是线程公有的，哪部分是私有的？&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img&#xA;        class=&#34;lazyload&#34;&#xA;        src=&#34;https://www.ithome.me/svg/loading.min.svg&#34;&#xA;        data-src=&#34;https://img.ibook8.club/mweb/16044872296914.jpg&#34;&#xA;        data-srcset=&#34;https://img.ibook8.club/mweb/16044872296914.jpg, https://img.ibook8.club/mweb/16044872296914.jpg 1.5x, https://img.ibook8.club/mweb/16044872296914.jpg 2x&#34;&#xA;        data-sizes=&#34;auto&#34;&#xA;        alt=&#34;https://img.ibook8.club/mweb/16044872296914.jpg&#34;&#xA;        title=&#34;https://img.ibook8.club/mweb/16044872296914.jpg&#34; /&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>快速理解二十三种设计模式(速记)</title>
      <link>https://www.ithome.me/post/2020/10/21/%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3%E4%BA%8C%E5%8D%81%E4%B8%89%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 21 Oct 2020 12:17:10 +0800</pubDate>
      <guid>https://www.ithome.me/post/2020/10/21/%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3%E4%BA%8C%E5%8D%81%E4%B8%89%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h2 id=&#34;设计模式六大原则&#34;&gt;设计模式六大原则&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单一职责原则（Single Responsibility Principle）&lt;/li&gt;&#xA;&lt;li&gt;里氏替换原则（Liskov Substitution Principle）&lt;/li&gt;&#xA;&lt;li&gt;依赖倒置原则（Dependence Inversion Principle）&lt;/li&gt;&#xA;&lt;li&gt;接口隔离原则（Interface Segregation Principle）&lt;/li&gt;&#xA;&lt;li&gt;迪米特法则（最少知道原则）(Law of Demeter)&lt;/li&gt;&#xA;&lt;li&gt;合成复用原则（Composite Reuse Principle）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;设计模式三大类&#34;&gt;设计模式三大类&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;创建型模式（Creational Pattern）：对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。&#xA;（5种）工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;结构型模式（Structural Pattern）：关注于对象的组成以及对象之间的依赖关系，描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。&#xA;（7种）适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;行为型模式（Behavioral Pattern）：关注于对象的行为问题，是对在不同的对象之间划分责任和算法的抽象化；不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。&#xA;（11种）策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;简单工厂模式&#34;&gt;简单工厂模式&lt;/h2&gt;&#xA;&lt;p&gt;一个工厂根据不同的参数返回不同的产品&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;水果店理解为一个简单工厂，你要苹果，他给你苹果，你要梨子，他就给你梨子。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;工厂模式&#34;&gt;工厂模式&lt;/h2&gt;&#xA;&lt;p&gt;一个工厂创建一个具体的产品，一个产品对应一个工厂类。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;宝马x1一个工厂类，x2一个工厂类，x3一个工厂类，奔驰A级一个工厂类，C级一个工厂类&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;抽象工厂模式&#34;&gt;抽象工厂模式&lt;/h2&gt;&#xA;&lt;p&gt;一个工厂创建一类产品，一类产品对应一个工厂。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;比如汽车制造工厂是个抽象工厂，它既可以生产宝马X1，也可以生产X2，X3。罐头厂是一个抽象工厂，它可以生产橘子罐头，也可以生产黄桃罐头。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;单例模式&#34;&gt;单例模式&lt;/h2&gt;&#xA;&lt;p&gt;这个没啥好说的，保证一个类仅有一个实例，并提供一个访问它的全局访问点。&#xA;需要记忆的是&lt;code&gt;懒汉式&lt;/code&gt;和&lt;code&gt;饿汉式&lt;/code&gt;。&#xA;懒汉式：需要的时候才实例化，常用的例子就是非空检查和双重检查式的实现。&#xA;饿汉式：类加载的时候就先实例化。&#xA;类似这样的&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton instance &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Singleton();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;饿汉式会线程安全些。&#xA;我们用的最主流的方式是静态内部类的方式。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SingleInstance&lt;/span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SingleInstance&lt;/span&gt;(){}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SingleInstanceHolder&lt;/span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; SingleInstance INSTANCE &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; SingleInstance();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; SingleInstance &lt;span style=&#34;color:#a6e22e&#34;&gt;getInstance&lt;/span&gt;(){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; SingleInstanceHolder.&lt;span style=&#34;color:#a6e22e&#34;&gt;INSTANCE&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;一个省只会有一个省长。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Mac上安装yarn和nvm</title>
      <link>https://www.ithome.me/post/2020/10/19/mac%E4%B8%8A%E5%AE%89%E8%A3%85yarn%E5%92%8Cnvm/</link>
      <pubDate>Mon, 19 Oct 2020 17:38:08 +0800</pubDate>
      <guid>https://www.ithome.me/post/2020/10/19/mac%E4%B8%8A%E5%AE%89%E8%A3%85yarn%E5%92%8Cnvm/</guid>
      <description>&lt;p&gt;&lt;code&gt;Mac&lt;/code&gt;上安装&lt;code&gt;yarn&lt;/code&gt;最方便的方式就是命令行输入:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;brew install yarn&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但是这样会把&lt;code&gt;node&lt;/code&gt;也一并安装，作为开发者来说，保持多个&lt;code&gt;node&lt;/code&gt;版本是必要的，所以我们一般都是通过&lt;code&gt;nvm&lt;/code&gt;来管理&lt;code&gt;node&lt;/code&gt;版本。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;brew&lt;/code&gt;也提供过&lt;code&gt;brew install yarn --without-node&lt;/code&gt;命令，但是现在已经失效。不必再试。&lt;/p&gt;&#xA;&lt;p&gt;输入&lt;code&gt;brew install&lt;/code&gt;，根据提示我们发现目前可用的指令是&lt;code&gt;brew install yarn --ignore-dependencies&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;运行后会报错，提示你找不到&lt;code&gt;node&lt;/code&gt;，那么我们是不是可以把&lt;code&gt;nvm&lt;/code&gt;的&lt;code&gt;node&lt;/code&gt; link 到&lt;code&gt;brew&lt;/code&gt;去呢？&lt;/p&gt;&#xA;&lt;p&gt;答案是可以的，步骤如下(&lt;code&gt;node&lt;/code&gt;的版本号改为你实际使用的版本):&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;~ which node &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;/usr/local/opt/nvm/versions/node/v14.14.0/bin/node&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;~ mkdir /usr/local/Cellar/node&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;~ ln -s /usr/local/opt/nvm/versions/node/v14.14.0 /usr/local/Cellar/node&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;~ brew link --overwrite node&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;~ brew doctor&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;~ brew install yarn --ignore-dependencies&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;安装这个顺序操作就OK了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Windows Terminal添加右键菜单</title>
      <link>https://www.ithome.me/post/2020/05/02/windows-terminal%E6%B7%BB%E5%8A%A0%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/</link>
      <pubDate>Sat, 02 May 2020 11:38:08 +0800</pubDate>
      <guid>https://www.ithome.me/post/2020/05/02/windows-terminal%E6%B7%BB%E5%8A%A0%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/</guid>
      <description>&lt;p&gt;&lt;img&#xA;        class=&#34;lazyload&#34;&#xA;        src=&#34;https://www.ithome.me/svg/loading.min.svg&#34;&#xA;        data-src=&#34;https://img.ibook8.club/20200502161959.png&#34;&#xA;        data-srcset=&#34;https://img.ibook8.club/20200502161959.png, https://img.ibook8.club/20200502161959.png 1.5x, https://img.ibook8.club/20200502161959.png 2x&#34;&#xA;        data-sizes=&#34;auto&#34;&#xA;        alt=&#34;https://img.ibook8.club/20200502161959.png&#34;&#xA;        title=&#34;https://img.ibook8.club/20200502161959.png&#34; /&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;&#xA;&lt;p&gt;关于&lt;code&gt;Windows Terminal&lt;/code&gt;的配置，后面有空再讲。&lt;/p&gt;&#xA;&lt;p&gt;今天要说的是如何实现在当前目录打开&lt;code&gt;Windows Terminal&lt;/code&gt;，类似&lt;code&gt;Mac&lt;/code&gt;上的&lt;code&gt;Go2Shell&lt;/code&gt;效果。&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;</description>
    </item>
    <item>
      <title>Java集合</title>
      <link>https://www.ithome.me/post/2020/04/23/java%E9%9B%86%E5%90%88/</link>
      <pubDate>Thu, 23 Apr 2020 11:38:08 +0800</pubDate>
      <guid>https://www.ithome.me/post/2020/04/23/java%E9%9B%86%E5%90%88/</guid>
      <description>&lt;p&gt;&lt;img&#xA;        class=&#34;lazyload&#34;&#xA;        src=&#34;https://www.ithome.me/svg/loading.min.svg&#34;&#xA;        data-src=&#34;https://img.ibook8.club/mweb/15876138880086.jpg&#34;&#xA;        data-srcset=&#34;https://img.ibook8.club/mweb/15876138880086.jpg, https://img.ibook8.club/mweb/15876138880086.jpg 1.5x, https://img.ibook8.club/mweb/15876138880086.jpg 2x&#34;&#xA;        data-sizes=&#34;auto&#34;&#xA;        alt=&#34;https://img.ibook8.club/mweb/15876138880086.jpg&#34;&#xA;        title=&#34;https://img.ibook8.club/mweb/15876138880086.jpg&#34; /&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>傻瓜函数式编程</title>
      <link>https://www.ithome.me/post/2019/03/05/%E5%82%BB%E7%93%9C%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Tue, 05 Mar 2019 14:37:40 +0800</pubDate>
      <guid>https://www.ithome.me/post/2019/03/05/%E5%82%BB%E7%93%9C%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;文章来自网络&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;傻瓜函数式编程&#34;&gt;傻瓜函数式编程&lt;/h1&gt;&#xA;&lt;p&gt;2006年6月19日，星期一&lt;/p&gt;&#xA;&lt;h3 id=&#34;开篇&#34;&gt;开篇&lt;/h3&gt;&#xA;&lt;p&gt;我们这些码农做事都是很拖拉的。每天例行报到后，先来点咖啡，看看邮件还有RSS订阅的文章。然后翻翻新闻还有那些技术网站上的更新，再过一遍编程论坛口水区里那些无聊的论战。最后从头把这些再看一次以免错过什么精彩的内容。然后就可以吃午饭了。饭饱过后，回来盯着IDE发一会呆，再看看邮箱，再去搞杯咖啡。光阴似箭，可以回家了……&lt;/p&gt;&#xA;&lt;p&gt;（在被众人鄙视之前）我唯一想说的是，在这些拖拉的日子里总会时不时读到一些&lt;a href=&#34;http://www.baike.com/wiki/%E4%B8%8D%E6%98%8E%E8%A7%89%E5%8E%89&#34; target=&#34;_blank&#34; rel=&#34;noopener noreffer&#34;&gt;不明觉厉&lt;/a&gt;&#xA;的文章。如果没有打开不应该打开的网站，每隔几天你都可以看到至少一篇这样的东西。它们的共性：难懂，耗时，于是这些文章就慢慢的堆积成山了。很快你就会发现自己已经累积了一堆的收藏链接还有数不清的PDF文件，此时你只希望隐入一个杳无人烟的深山老林里什么也不做，用一年半载好好的消化这些私藏宝贝。当然，我是说最好每天还是能有人来给送吃的顺带帮忙打扫卫生倒垃圾，哇哈哈。&lt;/p&gt;&#xA;&lt;p&gt;我不知道你都收藏了些什么，我的阅读清单里面相当大部分都是函数式编程相关的东东：基本上是最难啃的。这些文章充斥着无比枯燥的教科书语言，我想就连那些在华尔街浸淫10年以上的大牛都无法搞懂这些函数式编程（简称FP）文章到底在说什么。你可以去花旗集团或者德意志银行找个项目经理来问问&lt;sup name=&#34;a1&#34;&gt;&lt;a href=&#34;#f1&#34; rel=&#34;&#34;&gt;1&lt;/a&gt;&#xA;&lt;/sup&gt;：你们为什么要选JMS而不用Erlang？答案基本上是：我认为这个学术用的语言还无法胜任实际应用。可是，现有的一些系统不仅非常复杂还需要满足十分严苛的需求，它们就都是用函数式编程的方法来实现的。这，就说不过去了。&lt;/p&gt;&#xA;&lt;p&gt;关于FP的文章确实比较难懂，但我不认为一定要搞得那么晦涩。有一些历史原因造成了这种知识断层，可是FP概念本身并不难理解。我希望这篇文章可以成为一个“FP入门指南”，帮助你从&lt;a href=&#34;http://zh.wikipedia.org/zh/%E6%8C%87%E4%BB%A4%E5%BC%8F%E7%B7%A8%E7%A8%8B&#34; target=&#34;_blank&#34; rel=&#34;noopener noreffer&#34;&gt;指令式编程&lt;/a&gt;&#xA;走向&lt;a href=&#34;http://zh.wikipedia.org/zh/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80&#34; target=&#34;_blank&#34; rel=&#34;noopener noreffer&#34;&gt;函数式编程&lt;/a&gt;&#xA;。先来点咖啡，然后继续读下去。很快你对FP的理解就会让同事们刮目相看了。&lt;/p&gt;&#xA;&lt;p&gt;什么是函数式编程（Functional Programming，FP）？它从何而来？可以吃吗？倘若它真的像那些鼓吹FP的人说的那么好，为什么实际应用中那么少见？为什么只有那些在读博士的家伙想要用它？而最重要的是，它母亲的怎么就那么难学？那些所谓的closure、continuation，currying，lazy evaluation还有no side effects都是什么东东（译者：本着保留专用术语的原则，此处及下文类似情形均不译）？如果没有那些大学教授的帮忙怎样把它应用到实际工程里去？为什么它和我们熟悉的万能而神圣的指令式编程那么的不一样？&lt;/p&gt;&#xA;&lt;p&gt;我们很快就会解开这些谜团。刚才我说过实际工程和学术界之间的知识断层是有其历史原因的，那么就先让我来解释一下这个问题。答案，就在接下来的一次公园漫步中：&lt;/p&gt;&#xA;&lt;h3 id=&#34;公园漫步&#34;&gt;公园漫步&lt;/h3&gt;&#xA;&lt;p&gt;时间机器启动……我们来到公元前380年，也就是2000多年前的雅典城外。这是一个阳光明媚的久违的春天，&lt;a href=&#34;http://zh.wikipedia.org/zh/%E6%9F%8F%E6%8B%89%E5%9B%BE&#34; target=&#34;_blank&#34; rel=&#34;noopener noreffer&#34;&gt;柏拉图&lt;/a&gt;&#xA;和一个帅气的小男仆走在一片橄榄树荫下。他们正准备前往一个学院。天气很好，吃得很饱，渐渐的，两人的谈话转向了哲学。&lt;/p&gt;&#xA;&lt;p&gt;“你看那两个学生，哪一个更高一些？”，柏拉图小心的选择用字，以便让这个问题更好的引导眼前的这个小男孩。  &lt;br&gt;&#xA;小男仆望向水池旁边的两个男生，“他们差不多一样高。”。  &lt;br&gt;&#xA;“‘差不多一样高’是什么意思？”柏拉图问。 &lt;br&gt;&#xA;“嗯……从这里看来他们是一样高的，但是如果走近一点我肯定能看出差别来。”  &lt;br&gt;&#xA;柏拉图笑了。他知道这个小孩已经朝他引导的方向走了。“这么说来你的意思是世界上没有什么东西是完全相同的咯？”  &lt;br&gt;&#xA;思考了一会，小男孩回答：“是的。万物之间都至少有一丁点差别，哪怕我们无法分辨出来。” &lt;br&gt;&#xA;说到点子上了！“那你说，如果世界上没有什么东西是完全相等的，你怎么理解‘完全相等’这个概念？”  &lt;br&gt;&#xA;小男仆看起来很困惑。“这我就不知道了。”&lt;/p&gt;&#xA;&lt;p&gt;这是人类第一次试图了解数学的本质。柏拉图认为我们所在的世界中，万事万物都是完美模型的一个近似。他同时意识到虽然我们不能感受到完美的模型，但这丝毫不会阻止我们了解完美模型的概念。柏拉图进而得出结论：完美的数学模型只存在于另外一个世界，而因为某种原因我们却可以通过联系着这两个世界的一个纽带来认识这些模型。一个简单的例子就是完美的圆形。没有人见过这样的一个圆，但是我们知道怎样的圆是完美的圆，而且可以用公式把它描述出来。&lt;/p&gt;&#xA;&lt;p&gt;如此说来，什么是数学呢？为什么可以用数学法则来描述我们的这个宇宙？我们所处的这个世界中万事万物都可以用数学来描述吗？&lt;sup name=&#34;a2&#34;&gt;&lt;a href=&#34;#f2&#34; rel=&#34;&#34;&gt;2&lt;/a&gt;&#xA;&lt;/sup&gt;&#xA;数理哲学是一门很复杂的学科。它和其他多数哲学一样，更着重于提出问题而不是给出答案。数学就像拼图一样，很多结论都是这样推导出来的：先是确立一些互不冲突的基础原理，以及一些操作这些原理的规则，然后就可以把这些原理以及规则拼凑起来形成新的更加复杂的规则或是定理了。数学家把这种方法称为“形式系统”或是“演算”。如果你想做的话，可以用形式系统描述俄罗斯方块这个游戏。而事实上，俄罗斯方块这个游戏的实现，只要它正确运行，就是一个形式系统。只不过它以一种不常见的形式表现出来罢了。&lt;/p&gt;&#xA;&lt;p&gt;如果&lt;a href=&#34;http://zh.wikipedia.org/wiki/%E5%8D%8A%E4%BA%BA%E9%A9%AC%E5%BA%A7%CE%B1&#34; target=&#34;_blank&#34; rel=&#34;noopener noreffer&#34;&gt;半人马阿尔法&lt;/a&gt;&#xA;上有文明存在的话，那里的生物可能无法解读我们的俄罗斯方块形式系统甚至是简单的圆形的形式系统，因为它们感知世界的唯一器官可能只有鼻子（译者：偶的妈你咋知道？）也许它们是无法得知俄罗斯方块的形式系统了，但是它们很有可能知道圆形。它们的圆形我们可能没法解读，因为我们的鼻子没有它们那么灵敏（译者：那狗可以么？）可是只要越过形式系统的表示方式（比如通过使用“超级鼻子”之类的工具来感知这些用味道表示的形式系统，然后使用标准的解码技术把它们翻译成人类能理解的语言），那么任何有足够智力的文明都可以理解这些形式系统的本质。&lt;/p&gt;&#xA;&lt;p&gt;有意思的是，哪怕宇宙中完全不存在任何文明，类似俄罗斯方块还有圆形这样的形式系统依旧是成立的：只不过没有智慧生物去发现它们而已。这个时候如果忽然一个文明诞生了，那么这些具有智慧的生物就很有可能发现各种各样的形式系统，并且用它们发现的系统去描述各种宇宙法则。不过它们可能不会发现俄罗斯方块这样的形式系统，因为在它们的世界里没有俄罗斯方块这种东西嘛。有很多像俄罗斯方块这样的形式系统是与客观世界无关的，比如说自然数，很难说所有的自然数都与客观世界有关，随便举一个超级大的数，这个数可能就和世界上任何事物无关，因为这个世界可能不是无穷大的。&lt;/p&gt;&#xA;&lt;h3 id=&#34;历史回眸3&#34;&gt;历史回眸&lt;sup name=&#34;a3&#34;&gt;&lt;a href=&#34;#f3&#34; rel=&#34;&#34;&gt;3&lt;/a&gt;&#xA;&lt;/sup&gt;&lt;/h3&gt;&#xA;&lt;p&gt;再次启动时间机……这次到达的是20世纪30年代，离今天近了很多。无论&lt;a href=&#34;http://zh.wikipedia.org/wiki/%E6%96%B0%E5%A4%A7%E9%99%B8&#34; target=&#34;_blank&#34; rel=&#34;noopener noreffer&#34;&gt;新&lt;/a&gt;&#xA;&lt;a href=&#34;http://zh.wikipedia.org/wiki/%E8%88%8A%E5%A4%A7%E9%99%B8&#34; target=&#34;_blank&#34; rel=&#34;noopener noreffer&#34;&gt;旧&lt;/a&gt;&#xA;大陆，经济大萧条都造成了巨大的破坏。社会各阶层几乎每一个家庭都深受其害。只有极其少数的几个地方能让人们免于遭受穷困之苦。几乎没有人能够幸运的在这些避难所里度过危机，注意，我说的是几乎没有，还真的有这么些幸运儿，比如说当时普林斯顿大学的数学家们。&lt;/p&gt;&#xA;&lt;p&gt;新建成的哥特式办公楼给普林斯顿大学带来一种天堂般的安全感。来自世界各地的逻辑学者应邀来到普林斯顿，他们将组建一个新的学部。正当大部分美国人还在为找不到一片面包做晚餐而发愁的时候，在普林斯顿却是这样一番景象：高高的天花板和木雕包覆的墙，每天品茶论道，漫步丛林。&lt;/p&gt;&#xA;&lt;p&gt;一个名叫&lt;a href=&#34;http://zh.wikipedia.org/zh/%E9%98%BF%E9%9A%86%E4%BD%90%C2%B7%E9%82%B1%E5%A5%87&#34; target=&#34;_blank&#34; rel=&#34;noopener noreffer&#34;&gt;阿隆佐·邱奇&lt;/a&gt;&#xA;(Alonzo Church)的年轻数学家就过着这样优越的生活。阿隆佐本科毕业于普林斯顿后被留在研究院。他觉得这样的生活完全没有必要，于是他鲜少出现在那些数学茶会中也不喜欢到树林里散心。阿隆佐更喜欢独处：自己一个人的时候他的工作效率更高。尽管如此他还是和普林斯顿学者保持着联系，这些人当中有&lt;a href=&#34;http://zh.wikipedia.org/zh/%E8%89%BE%E4%BC%A6%C2%B7%E5%9B%BE%E7%81%B5&#34; target=&#34;_blank&#34; rel=&#34;noopener noreffer&#34;&gt;艾伦·图灵&lt;/a&gt;&#xA;、&lt;a href=&#34;http://zh.wikipedia.org/zh/%E7%BA%A6%E7%BF%B0%C2%B7%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC&#34; target=&#34;_blank&#34; rel=&#34;noopener noreffer&#34;&gt;约翰·冯·诺伊曼&lt;/a&gt;&#xA;、&lt;a href=&#34;http://zh.wikipedia.org/zh-hant/%E5%BA%93%E5%B0%94%E7%89%B9%C2%B7%E5%93%A5%E5%BE%B7%E5%B0%94&#34; target=&#34;_blank&#34; rel=&#34;noopener noreffer&#34;&gt;库尔特·哥德尔&lt;/a&gt;&#xA;。&lt;/p&gt;&#xA;&lt;p&gt;这四个人都对形式系统感兴趣。相对于现实世界，他们更关心如何解决抽象的数学问题。而他们的问题都有这么一个共同点：都在尝试解答关于计算的问题。诸如：如果有一台拥有无穷计算能力的超级机器，可以用来解决什么问题？它可以自动的解决这些问题吗？是不是还是有些问题解决不了，如果有的话，是为什么？如果这样的机器采用不同的设计，它们的计算能力相同吗？&lt;/p&gt;&#xA;&lt;p&gt;在与这些人的合作下，阿隆佐设计了一个名为&lt;a href=&#34;http://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97&#34; target=&#34;_blank&#34; rel=&#34;noopener noreffer&#34;&gt;lambda演算&lt;/a&gt;&#xA;的形式系统。这个系统实质上是为其中一个超级机器设计的编程语言。在这种语言里面，函数的参数是函数，返回值也是函数。这种函数用希腊字母lambda（&lt;a href=&#34;http://en.wikipedia.org/wiki/Lambda&#34; target=&#34;_blank&#34; rel=&#34;noopener noreffer&#34;&gt;λ&lt;/a&gt;&#xA;），这种系统因此得名&lt;sup name=&#34;a4&#34;&gt;&lt;a href=&#34;#f4&#34; rel=&#34;&#34;&gt;4&lt;/a&gt;&#xA;&lt;/sup&gt;。有了这种形式系统，阿隆佐终于可以分析前面的那些问题并且能够给出答案了。&lt;/p&gt;&#xA;&lt;p&gt;除了阿隆佐·邱奇，艾伦·图灵也在进行类似的研究。他设计了一种完全不同的系统（后来被称为&lt;a href=&#34;http://zh.wikipedia.org/zh/%E5%9B%BE%E7%81%B5%E6%9C%BA&#34; target=&#34;_blank&#34; rel=&#34;noopener noreffer&#34;&gt;图灵机&lt;/a&gt;&#xA;），并用这种系统得出了和阿隆佐相似的答案。到了后来人们证明了图灵机和lambda演算的能力是一样的。&lt;/p&gt;&#xA;&lt;p&gt;如果二战没有发生，这个故事到这里就应该结束了，我的这篇小文没什么好说的了，你们也可以去看看有什么其他好看的文章。可是二战还是爆发了，整个世界陷于火海之中。那时的美军空前的大量使用炮兵。为了提高轰炸的精度，军方聘请了大批数学家夜以继日的求解各种差分方程用于计算各种火炮发射数据表。后来他们发现单纯手工计算这些方程太耗时了，为了解决这个问题，各种各样的计算设备应运而生。IBM制造的Mark一号就是用来计算这些发射数据表的第一台机器。Mark一号重5吨，由75万个零部件构成，每一秒可以完成3次运算。&lt;/p&gt;&#xA;&lt;p&gt;战后，人们为提高计算能力而做出的努力并没有停止。1949年第一台电子离散变量自动计算机诞生并取得了巨大的成功。它是&lt;a href=&#34;http://zh.wikipedia.org/zh/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84&#34; target=&#34;_blank&#34; rel=&#34;noopener noreffer&#34;&gt;冯·诺伊曼设计架构&lt;/a&gt;&#xA;的第一个实例，也是一台现实世界中实现的图灵机。相比他的这些同事，那个时候阿隆佐的运气就没那么好了。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
