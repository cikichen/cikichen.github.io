<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>内存泄漏 on 编程心语</title>
    <link>https://www.ithome.me/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</link>
    <description>Recent content in 内存泄漏 on 编程心语</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <copyright>©{year}, All Rights Reserved. Simon Chen</copyright>
    <lastBuildDate>Wed, 21 Oct 2020 09:38:08 +0800</lastBuildDate>
    <atom:link href="https://www.ithome.me/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Android内存泄漏分析</title>
      <link>https://www.ithome.me/post/2020/10/21/android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 21 Oct 2020 09:38:08 +0800</pubDate>
      <guid>https://www.ithome.me/post/2020/10/21/android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;&#xA;&lt;p&gt;Android内存泄漏，也就是我们常说的&lt;code&gt;OOM(out of memory)&lt;/code&gt;，&lt;code&gt;OOM&lt;/code&gt;的后果大家都知道，严重影响APP的体验，轻则卡顿，重则闪退。而且内存泄漏在低端机上一般都会伴随着&lt;code&gt;ANR&lt;/code&gt;，所以一定要重视它。&lt;/p&gt;&#xA;&lt;p&gt;造成内存泄漏的常见因素有：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IO操作&lt;/li&gt;&#xA;&lt;li&gt;Bitmap&lt;/li&gt;&#xA;&lt;li&gt;Context&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单例持有引用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Service&#xA;&lt;ul&gt;&#xA;&lt;li&gt;BroadcastReceiver&lt;/li&gt;&#xA;&lt;li&gt;ContentObserver&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Handler&lt;/li&gt;&#xA;&lt;li&gt;Thread&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;分析方法&#34;&gt;分析方法&lt;/h2&gt;&#xA;&lt;p&gt;分析内存泄漏的常用方法：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;StrictMode， 在&lt;code&gt;Application&lt;/code&gt;的&lt;code&gt;onCreate&lt;/code&gt;中添加&lt;code&gt;StrictMode&lt;/code&gt;代码块&lt;/li&gt;&#xA;&lt;li&gt;Leakcanary，引用&lt;code&gt;Leakcanary&lt;/code&gt;库(&lt;strong&gt;常规手段，仅供参与，不应完全依赖这个库&lt;/strong&gt;)&lt;/li&gt;&#xA;&lt;li&gt;monkey，模拟用户点击操作，检查是否出现泄漏(&lt;strong&gt;推荐&lt;/strong&gt;，最有效的方法)&lt;/li&gt;&#xA;&lt;li&gt;adb命令手动触发&lt;code&gt;adb shell dumpsys meminfo packagename -d&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;Android Studio Memory Profiler，&lt;code&gt;Android Studio&lt;/code&gt;自带的分析工具，已经非常好用了&lt;/li&gt;&#xA;&lt;li&gt;MAT，终极神器，内存分析绕不开的话题(&lt;code&gt;Android Studio&lt;/code&gt;搞不定就靠它了)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Context&#xA;如果大家收集过内存泄漏的崩溃日志，会发现大量错误都是由&lt;code&gt;Context&lt;/code&gt;和&lt;code&gt;Handler&lt;/code&gt;造成。&#xA;因为我们开发中会大量用到&lt;code&gt;Context&lt;/code&gt;引用，而&lt;code&gt;Context&lt;/code&gt;在&lt;code&gt;Application&lt;/code&gt;，&lt;code&gt;Activity&lt;/code&gt;，&lt;code&gt;Service&lt;/code&gt;之类的地方会有自己的实例，而&lt;code&gt;Activity&lt;/code&gt;和&lt;code&gt;Service&lt;/code&gt;会因为生命周期的原因导致&lt;code&gt;Context&lt;/code&gt;实例被回收，如果你继续使用其引用就会因为弱引用问题导致错误出现。&#xA;&lt;code&gt;Context&lt;/code&gt;的引用也常见于单例模式。&#xA;所以建议大家尽可能使用&lt;code&gt;Application&lt;/code&gt;的&lt;code&gt;Context&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Bitmap&#xA;Bitmap的问题一般是因为没有对使用的图片及时释放所致。&#xA;图片一般因为体积问题，会导致占用比较多的内存&#xA;解决方案：就是在&lt;code&gt;Activity&lt;/code&gt;的&lt;code&gt;onDestroy()&lt;/code&gt;中及时回收内存。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;IO操作&#xA;FileOutputStream()未关闭，IO流忘记关闭&#xA;解决方案：及时关闭IO流，避免泄露&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Handler泄漏&#xA;由于Activity已经关闭，Handler任务还未执行完成，其引用了Activity的实例导致内存泄露&#xA;解决方案：在Activity的onDestroy()方法回收Handler&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;异步线程泄露&#xA;一般发生在线程执行耗时操作时，如下载，此时Activity关闭后，由于其被异步线程引用，导致无法被正常回收，从而内存泄露&#xA;解决方案：把线程作为对象提取出来，在Activity的onDestroy()方法阻塞线程&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;静态成员变量&#xA;开发中会定义许多&lt;code&gt;static&lt;/code&gt;变量，如果有大量的静态变量定义，并有引用资源，一定要在&lt;code&gt;onDestroy&lt;/code&gt;或其他地方及时释放(把变量置空即可)&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
  </channel>
</rss>
