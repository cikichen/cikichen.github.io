<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>设计模式 - Tag - 编程心语</title>
        <link>https://www.ithome.me/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
        <description>设计模式 - Tag - 编程心语</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>©{year}, All Rights Reserved. Simon Chen</copyright><lastBuildDate>Wed, 21 Oct 2020 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://www.ithome.me/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="self" type="application/rss+xml" /><item>
    <title>快速理解二十三种设计模式(速记)</title>
    <link>https://www.ithome.me/post/2020/10/21/%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3%E4%BA%8C%E5%8D%81%E4%B8%89%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
    <pubDate>Wed, 21 Oct 2020 00:00:00 &#43;0000</pubDate>
    <author>Simon</author>
    <guid>https://www.ithome.me/post/2020/10/21/%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3%E4%BA%8C%E5%8D%81%E4%B8%89%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
    <description><![CDATA[<h2 id="设计模式六大原则">设计模式六大原则</h2>
<ul>
<li>单一职责原则（Single Responsibility Principle）</li>
<li>里氏替换原则（Liskov Substitution Principle）</li>
<li>依赖倒置原则（Dependence Inversion Principle）</li>
<li>接口隔离原则（Interface Segregation Principle）</li>
<li>迪米特法则（最少知道原则）(Law of Demeter)</li>
<li>合成复用原则（Composite Reuse Principle）</li>
</ul>
<h2 id="设计模式三大类">设计模式三大类</h2>
<ol>
<li>
<p>创建型模式（Creational Pattern）：对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。
（5种）工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式</p>
</li>
<li>
<p>结构型模式（Structural Pattern）：关注于对象的组成以及对象之间的依赖关系，描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。
（7种）适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式</p>
</li>
<li>
<p>行为型模式（Behavioral Pattern）：关注于对象的行为问题，是对在不同的对象之间划分责任和算法的抽象化；不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。
（11种）策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式</p>
</li>
</ol>
<h2 id="简单工厂模式">简单工厂模式</h2>
<p>一个工厂根据不同的参数返回不同的产品</p>
<blockquote>
<p>水果店理解为一个简单工厂，你要苹果，他给你苹果，你要梨子，他就给你梨子。</p>
</blockquote>
<h2 id="工厂模式">工厂模式</h2>
<p>一个工厂创建一个具体的产品，一个产品对应一个工厂类。</p>
<blockquote>
<p>宝马x1一个工厂类，x2一个工厂类，x3一个工厂类，奔驰A级一个工厂类，C级一个工厂类</p>
</blockquote>
<h2 id="抽象工厂模式">抽象工厂模式</h2>
<p>一个工厂创建一类产品，一类产品对应一个工厂。</p>
<blockquote>
<p>比如汽车制造工厂是个抽象工厂，它既可以生产宝马X1，也可以生产X2，X3。罐头厂是一个抽象工厂，它可以生产橘子罐头，也可以生产黄桃罐头。</p>
</blockquote>
<h2 id="单例模式">单例模式</h2>
<p>这个没啥好说的，保证一个类仅有一个实例，并提供一个访问它的全局访问点。
需要记忆的是<code>懒汉式</code>和<code>饿汉式</code>。
懒汉式：需要的时候才实例化，常用的例子就是非空检查和双重检查式的实现。
饿汉式：类加载的时候就先实例化。
类似这样的</p>]]></description>
</item>
<item>
    <title>二十三种设计模式</title>
    <link>https://www.ithome.me/post/2015/01/30/%E4%BA%8C%E5%8D%81%E4%B8%89%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
    <pubDate>Fri, 30 Jan 2015 00:00:00 &#43;0000</pubDate>
    <author>SimonChen</author>
    <guid>https://www.ithome.me/post/2015/01/30/%E4%BA%8C%E5%8D%81%E4%B8%89%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
    <description><![CDATA[<p><!-- raw HTML omitted --><strong>23 design patterns.</strong><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<p><strong><!-- raw HTML omitted -->Creational Patterns<!-- raw HTML omitted --></strong></p>
<!-- raw HTML omitted -->
<p><strong><!-- raw HTML omitted -->Structural Patterns<!-- raw HTML omitted --></strong></p>
<!-- raw HTML omitted -->
<p><strong><!-- raw HTML omitted -->Behavioral Patterns<!-- raw HTML omitted --></strong></p>
<!-- raw HTML omitted -->
<p>原文:http://blog.csdn.net/u010019717/article/details/41172783</p>]]></description>
</item>
<item>
    <title>设计模式之接口隔离原则</title>
    <link>https://www.ithome.me/post/2013/12/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/</link>
    <pubDate>Wed, 25 Dec 2013 00:00:00 &#43;0000</pubDate>
    <author>SimonChen</author>
    <guid>https://www.ithome.me/post/2013/12/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/</guid>
    <description><![CDATA[<h1 id="接口隔离原则的定义">接口隔离原则的定义</h1>
<p>什么是接口？</p>
<ul>
<li>
<p>实例接口(Object Interface)，在Java中声明一个类，然后用new关键字产生一个实例，它是对一个类型的实物的描述，这是一种接口。Java中的类也是一种接口。</p>
</li>
<li>
<p>类接口(Class Interface)，Java中使用interface关键字定义的接口。
什么是隔离？</p>
</li>
<li>
<p>客户端不应该依赖它不需要的接口。</p>
</li>
<li>
<p>类间的依赖关系应该建立在最小的接口上。
 </p>
</li>
</ul>
<p><a href="http://www.ithome.me/wp-content/uploads/2013/12/uml1.png" target="_blank" rel="noopener noreffer"></a>
</p>]]></description>
</item>
</channel>
</rss>
