<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Objective-C - Tag - 编程心语</title>
        <link>https://www.ithome.me/tags/objective-c/</link>
        <description>Objective-C - Tag - 编程心语</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>©{year}, All Rights Reserved. Simon Chen</copyright><lastBuildDate>Wed, 06 Aug 2014 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://www.ithome.me/tags/objective-c/" rel="self" type="application/rss+xml" /><item>
    <title>objective-c知识点之【基本数据类型】</title>
    <link>https://www.ithome.me/post/2014/08/06/objective-c%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
    <pubDate>Wed, 06 Aug 2014 00:00:00 &#43;0000</pubDate>
    <author>SimonChen</author>
    <guid>https://www.ithome.me/post/2014/08/06/objective-c%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
    <description><![CDATA[<p>[caption id=&ldquo;attachment_629&rdquo; align=&ldquo;alignnone&rdquo; width=&ldquo;1264&rdquo;]<a href="http://www.ithome.me/wp-content/uploads/2014/08/Snip20140806_2.png" target="_blank" rel="noopener noreffer"></a>
 基本数据类型[/caption]</p>]]></description>
</item>
<item>
    <title>objective-c知识点之【编译器指令】</title>
    <link>https://www.ithome.me/post/2014/08/06/objective-c%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B9%8B%E7%BC%96%E8%AF%91%E5%99%A8%E6%8C%87%E4%BB%A4/</link>
    <pubDate>Wed, 06 Aug 2014 00:00:00 &#43;0000</pubDate>
    <author>SimonChen</author>
    <guid>https://www.ithome.me/post/2014/08/06/objective-c%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B9%8B%E7%BC%96%E8%AF%91%E5%99%A8%E6%8C%87%E4%BB%A4/</guid>
    <description><![CDATA[<p><a href="http://www.ithome.me/wp-content/uploads/2014/08/objc%e7%bc%96%e8%af%91%e5%99%a8%e6%8c%87%e4%bb%a4.png" target="_blank" rel="noopener noreffer"></a>
</p>
<p> </p>
<p>学习笔记，将就着看下吧</p>]]></description>
</item>
<item>
    <title>objective-c知识点之【预定义标识符】</title>
    <link>https://www.ithome.me/post/2014/08/06/objective-c%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B9%8B%E9%A2%84%E5%AE%9A%E4%B9%89%E6%A0%87%E8%AF%86%E7%AC%A6/</link>
    <pubDate>Wed, 06 Aug 2014 00:00:00 &#43;0000</pubDate>
    <author>SimonChen</author>
    <guid>https://www.ithome.me/post/2014/08/06/objective-c%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B9%8B%E9%A2%84%E5%AE%9A%E4%B9%89%E6%A0%87%E8%AF%86%E7%AC%A6/</guid>
    <description><![CDATA[<p>[caption id=&ldquo;attachment_632&rdquo; align=&ldquo;alignnone&rdquo; width=&ldquo;1082&rdquo;]<a href="http://www.ithome.me/wp-content/uploads/2014/08/Snip20140806_3.png" target="_blank" rel="noopener noreffer"></a>
 预定义标识[/caption]</p>]]></description>
</item>
<item>
    <title>Objective-C语法学习-@class指令</title>
    <link>https://www.ithome.me/post/2013/12/27/objective-c%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0-@class%E6%8C%87%E4%BB%A4/</link>
    <pubDate>Fri, 27 Dec 2013 00:00:00 &#43;0000</pubDate>
    <author>SimonChen</author>
    <guid>https://www.ithome.me/post/2013/12/27/objective-c%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0-@class%E6%8C%87%E4%BB%A4/</guid>
    <description><![CDATA[<p>在Objective-C中，指令</p>
<p>[objc]
@class XYPoint;
[/objc]</p>
<p>和</p>
<p>[objc]
#import &quot;XYPoint.h&quot;
[/objc]</p>
<p>作用是一样的。</p>
<p>但是使用@class指令提高了效率，因为编译器不需要处理整个XYPoint.h文件(虽然它很小)；而只需要知道XYPoint是一个类的名字。如果需要引用XYPoint类中的方法，@class指令是不够的，因为编译器需要更多消息。它需要知道该方法中有多少参数、它们是什么类型、方法的返回类型是什么。这时候就需要使用#import了。</p>]]></description>
</item>
<item>
    <title>Objective-C语法学习-id类型</title>
    <link>https://www.ithome.me/post/2013/12/26/objective-c%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0-id%E7%B1%BB%E5%9E%8B/</link>
    <pubDate>Thu, 26 Dec 2013 00:00:00 &#43;0000</pubDate>
    <author>SimonChen</author>
    <guid>https://www.ithome.me/post/2013/12/26/objective-c%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0-id%E7%B1%BB%E5%9E%8B/</guid>
    <description><![CDATA[<p>id数据类型可存储任何类型的对象。在objc中，id相当于c++里面的(void*)类型，相当于Java里面的object类型。</p>
<p>从某种意义来说，它是一般对象类型。例如：</p>
<p>[objc]
id number;
[/objc]</p>
<p>将number声明为id类型的变量。</p>
<p>可声明方法使其具有id类型的返回值，如下：</p>
<p>[objc]
-(id)newObject:(int)type;
[/objc]</p>
<p>这个程序行声明了一个名为newObject的实例方法，它具有名为type的单个整型参数并有id类型的返回值。</p>
<p>应该注意，对返回值和参数类型来说，Id是默认的类型。比如：</p>
<p>[objc]
+allocInit;
[/objc]</p>
<p>声明了一个返回id类型值的类方法。</p>
<h2 id="基本数据类型">基本数据类型</h2>
<p><a href="http://www.ithome.me/wp-content/uploads/2013/12/objc_type.jpg" target="_blank" rel="noopener noreffer"></a>
</p>]]></description>
</item>
<item>
    <title>Objective-C语法学习-self关键字</title>
    <link>https://www.ithome.me/post/2013/12/26/objective-c%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0-self%E5%85%B3%E9%94%AE%E5%AD%97/</link>
    <pubDate>Thu, 26 Dec 2013 00:00:00 &#43;0000</pubDate>
    <author>SimonChen</author>
    <guid>https://www.ithome.me/post/2013/12/26/objective-c%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0-self%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
    <description><![CDATA[<p>关键字self用来指明对象是当前方法的接收者。相当于Java中的this。</p>
<p>self代表当前对象对自身的引用。</p>
<p>使用方法如下：</p>
<p>[objc]
[self function];
[/objc]</p>]]></description>
</item>
<item>
    <title>Objective-C语法学习-static关键字</title>
    <link>https://www.ithome.me/post/2013/12/26/objective-c%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0-static%E5%85%B3%E9%94%AE%E5%AD%97/</link>
    <pubDate>Thu, 26 Dec 2013 00:00:00 &#43;0000</pubDate>
    <author>SimonChen</author>
    <guid>https://www.ithome.me/post/2013/12/26/objective-c%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0-static%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
    <description><![CDATA[<p>在变量声明前加上关键字static,可以使局部变量保留多次调用一个方法所得的值。如下：</p>
<p>[objc]
static int hitCount = 0;
[/objc]</p>
<p>声明整数hitCount是一个静态变量。和其他常量局部变量不同，静态变量的初始值为0，所以前面显示的初始化是多余的。此外，他们只在程序开始执行时初始化一次，并且在多次调用方法时保存这些数值。</p>
<p>所以编码序列</p>
<p>[objc]
-(void)showPage
{
static int pageCount = 0;
&hellip;.
++pageCount;
&hellip;.
}
[/objc]</p>
<p>可能出现在一个showPage方法中，它用于记录该方法的调用次数。只在程序开始时局部静态变量设置为0，并且在连续调用showPage方法时获得新值。</p>
<p>注意，将pageCount设置为局部静态变量和实例变量之间的区别。对于前一种情况，pageCount能记录调用showPage方法的所有对象打印页面的数目。对于后一种情况，pageCount变量可以计算每个对象的页面数目，因为每个对象都有自己的pageCount副本。</p>
<p>记住只能在定义静态和局部变量的方法中访问这些变量。所以，即使静态变量pageCount，也只能在showPage函数中访问。可以将变量的声明移到所有方法声明的外部(通常放在implementation文件的开始处)，这样所有方法都可以访问它们，如：</p>
<p>[objc]
#import &quot;Printer.h&quot;</p>
<p>static int pageCount;</p>
<p>@implementation Printer</p>
<p>&hellip;</p>
<p>@end
[/objc]</p>
<p>这样，该文件中包含的所有实例或者类方法都可以访问变量pageCount。</p>]]></description>
</item>
<item>
    <title>Objective-C语法学习-具有多个参数的方法</title>
    <link>https://www.ithome.me/post/2013/12/26/objective-c%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%85%B7%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/</link>
    <pubDate>Thu, 26 Dec 2013 00:00:00 &#43;0000</pubDate>
    <author>SimonChen</author>
    <guid>https://www.ithome.me/post/2013/12/26/objective-c%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%85%B7%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
    <description><![CDATA[<p>Objective-C如何实现多参数输入呢？</p>
<p>先复习一下objc怎么传递参数，例如：</p>
<p>[objc]
//声明部分
-(void)setNumerator:(int)n;</p>
<p>//测试部分
[myFraction setNumerator:1];
[/objc]</p>
<p>通过方法名后面跟上冒号，表示接受的参数。</p>
<h1 id="带参数名的方法">带参数名的方法</h1>
<p>如果要实现多个参数传递呢？我们可以通过下面的方式实现：</p>
<p>[objc]
[instance setX:(int)x andY:(int)y];
[/objc]</p>
<p>这种感觉。</p>
<p>我们看一个具体的例子：</p>
<p>接口文件：Fraction.h</p>
<p>[objc]
#import Foundation/Foundation.h</p>
<p>@interface Fraction:NSObject</p>
<p>@property int numerator,denominator;
-(void)print;
-(void)setTo:(int)n over:(int)d;
-(double)convertToNum;</p>
<p>@end
[/objc]</p>
<p>然后，在实现文件中添加新方法定义。</p>
<p>实现文件：Fraction.m</p>
<p>[objc]
#import &quot;Fraction.h&quot;</p>
<p>@implementation Fraction
@synthesize numerator,denominator;
-(void)print
{
NSLog(@&quot;%i/%i&quot;,numerator,denominator);
}
-(double)convertToNum
{
if(denominator!=0)
return (double)numerator/denominator;
else
return 1.0;
}
-(void)setTo:(int)n over:(int)d
{
numerator = n;
denominator = d;
}
@end
[/objc]</p>
<p>setTo: over:方法接受两个整型参数，n和d，并把他们赋值给该分数对应的域numerator和denominator。</p>]]></description>
</item>
<item>
    <title>Objective-C语法学习-合成存取器方法@property</title>
    <link>https://www.ithome.me/post/2013/12/26/objective-c%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%90%88%E6%88%90%E5%AD%98%E5%8F%96%E5%99%A8%E6%96%B9%E6%B3%95@property/</link>
    <pubDate>Thu, 26 Dec 2013 00:00:00 &#43;0000</pubDate>
    <author>SimonChen</author>
    <guid>https://www.ithome.me/post/2013/12/26/objective-c%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%90%88%E6%88%90%E5%AD%98%E5%8F%96%E5%99%A8%E6%96%B9%E6%B3%95@property/</guid>
    <description><![CDATA[<p>在objc中，可以自动生成设置函数方法和获取函数方法（统称为存取器方法）。</p>
<p>第一步是在接口部分中使用@property指令标识属性。这些属性通常是实例变量。在Fraction类中，两个实例变量numerator和denominator都属于此类属性。例如：</p>
<p>[objc]@interface Fraction:NSObject
{
int numerator;
int denominator;
}
@property int numerator,denominator;
-(void)print;
-(double)convertToNum;
@end
[/objc]</p>
<p>注意，我们没有包括下列设置函数方法和获取函数方法的定义：numerator、denominator、setNumerator和setDenominator。我们要让objc-2.0编译器为我们自动生成或合成这些方法。如何完成呢？只需在实现部分中使用@synthesize指令即可，如下：</p>
<p>[objc]
#import &quot;Fraction.h&quot;
@implementation Fraction
@synthesize numerator,denominator;
-(void)print
{
NSLog(@&quot;%i/%i&quot;,numerator,denominator);
}
-(double)convertToNum
{
if(denominator != 0)
return (double)numerator/denominator;
else
return 1.0;
}
@end
[/objc]</p>
<p>下面这行内容告诉objective-c编译器，为两个实例变量（numerator和denominator）的每一个生成一对设置函数方法和获取函数方法：</p>
<p>[objc]@synthesize numerator,denominator;[/objc]</p>
<p>通常，如果有称为X的实例变量，那么在实现部分包括以下行会导致编译器自动实现一个获取函数方法X和一个设置函数方法setX:</p>
<p>[objc]@synthesize x[/objc]</p>
<p>即使此处看起来并非什么大事，但是让编译器完成这项工作是值得的，因为生成的存取器方法是高效的，并且在使用多个核心的多台机器上，使用多线程时也可正常运行。</p>]]></description>
</item>
<item>
    <title>Objective-C语法学习-对象传递</title>
    <link>https://www.ithome.me/post/2013/12/26/objective-c%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%AF%B9%E8%B1%A1%E4%BC%A0%E9%80%92/</link>
    <pubDate>Thu, 26 Dec 2013 00:00:00 &#43;0000</pubDate>
    <author>SimonChen</author>
    <guid>https://www.ithome.me/post/2013/12/26/objective-c%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0-%E5%AF%B9%E8%B1%A1%E4%BC%A0%E9%80%92/</guid>
    <description><![CDATA[<p>我们知道了Objective-C中传递参数的方式，但是如果我们需要把一个实例对象作为参数传递时该如何做呢？</p>
<p>假设我们有一个Fraction类，现在我们有一个方法需要接受它自己的实例对象，那么我们可以这样做：</p>
<p>[objc]
-(void)add:(Fraction*)f;
[/objc]</p>
<p>注意参数f的声明：</p>
<p>[objc]
(Fraction*)f
[/objc]</p>
<p>这句语句说明add:方法的参数类型是Fraction类。<strong>星号是必须的</strong>，所以声明</p>
<p>[objc]
(Fraction)f
[/objc]</p>
<p>是不正确的。</p>
<p>使用方法如下：
[objc]
Fraction* aFraction = [[Fraction alloc] init];
Fraction* bFraction = [[Fraction alloc] init];</p>
<p>[aFraction add:bFraction];
[/objc]</p>]]></description>
</item>
</channel>
</rss>
